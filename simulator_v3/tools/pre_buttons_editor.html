<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Prosty edytor przycisków nad obrazem (SVG) — uproszczony</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="../g_styles.css">
<link rel="stylesheet" href="tools.css">
<style>
  /* Minimalne style lokalne (możesz przenieść do tools.css) */
  .image-wrap { position:relative; display:inline-block; max-width:100vmin; max-height:100vmin; background:var(--surface-1); border-radius:6px; overflow:hidden; }
  .image-wrap img { display:block; max-width:100%; height:auto; user-select:none; -webkit-user-drag:none; }
  .svg-overlay { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
  .svg-button-group { pointer-events:all; cursor:pointer; }
  .svg-button-bg { transition:stroke .12s; }
  .card.small { margin-bottom:0.75rem; }
  .kv { display:flex; gap:0.6rem; align-items:center; }
  label { min-width:5rem; font-weight:600; }
  input[type="text"], textarea { width:100%; background:var(--surface-2); color:#e6eef6; border-radius:6px; padding:0.4rem; border:1px solid rgba(255,255,255,0.04); }
  textarea.output { min-height:6rem; font-family:monospace; resize:vertical; }
  .controls { display:flex; gap:0.5rem; flex-wrap:wrap; }
  .btn { all:unset; cursor:pointer; padding:0.4rem 0.7rem; border-radius:6px; background:var(--accent-2); color:#031018; font-weight:700; }
</style>
</head>
<body class="app-root">
  <div class="container small">
    <header class="header">
      <h1 class="title">Edytor przycisków nad obrazem — prosty</h1>
      <p class="lead">Wczytaj obraz → dwa klik = dodaj przycisk; klik = edytuj (name + hidden data).</p>
    </header>

    <div class="card small">
      <h3 class="card-title">1. Wczytaj obraz</h3>
      <div class="card-body">
        <input id="fileInput" type="file" accept="image/*">
        <p class="small-muted">Obraz skalowany do max 100vmin.</p>
      </div>
    </div>

    <div class="card small">
      <h3 class="card-title">2. Obraz + przyciski</h3>
      <div class="card-body">
        <div id="imageContainer" class="image-wrap" style="display:none;"></div>
        <p class="small-muted">Podwójne kliknięcie dodaje przycisk. Pojedyncze kliknięcie wybiera go do edycji.</p>
      </div>
    </div>

    <div class="card small">
      <h3 class="card-title">3. Edycja</h3>
      <div class="card-body">
        <div class="kv">
          <label>Wybrany:</label><div id="selectedInfo" class="small-muted">brak</div>
        </div>
        <div class="kv" style="margin-top:0.5rem;">
          <label>Nazwa:</label><input id="nameInput" type="text" placeholder="Nazwa...">
        </div>
        <div class="kv" style="margin-top:0.5rem;">
          <label>Dane (ukryte):</label><input id="dataInput" type="text" placeholder="Dowolne dane...">
        </div>
        <div class="controls" style="margin-top:0.6rem;">
          <button id="applyBtn" class="btn">Zastosuj</button>
          <button id="deleteBtn" class="btn">Usuń</button>
          <button id="clearBtn" class="btn">Wyczyść przyciski</button>
        </div>

        <label style="margin-top:0.7rem; display:block;">JSON unikatowych nazw:</label>
        <textarea id="jsonOutput" class="output" readonly></textarea>

        <label style="margin-top:0.5rem; display:block;">SVG (warstwa przycisków):</label>
        <textarea id="svgOutput" class="output" readonly></textarea>
      </div>
    </div>
  </div>

<script>
/* Uproszczona wersja: logiczne, krótkie funkcje */
const fileInput = document.getElementById('fileInput');
const imageContainer = document.getElementById('imageContainer');
const nameInput = document.getElementById('nameInput');
const dataInput = document.getElementById('dataInput');
const applyBtn = document.getElementById('applyBtn');
const deleteBtn = document.getElementById('deleteBtn');
const clearBtn = document.getElementById('clearBtn');
const selectedInfo = document.getElementById('selectedInfo');
const jsonOutput = document.getElementById('jsonOutput');
const svgOutput = document.getElementById('svgOutput');

let imgEl = null, svgEl = null, selected = null, counter = 0;

/* LOAD IMAGE */
fileInput.addEventListener('change', e => {
  const f = e.target.files && e.target.files[0]; if (!f) return;
  const url = URL.createObjectURL(f);
  loadImage(url);
});

function loadImage(url) {
  // reset
  imageContainer.innerHTML = '';
  selected = null;
  selectedInfo.textContent = 'brak';
  nameInput.value = dataInput.value = '';
  jsonOutput.value = svgOutput.value = '';

  imgEl = document.createElement('img');
  imgEl.src = url; imgEl.alt = 'obraz'; imgEl.draggable = false;

  imgEl.onload = () => {
    const w = imgEl.naturalWidth, h = imgEl.naturalHeight;
    imageContainer.style.display = 'inline-block';

    // svg overlay z viewBox naturalnych wymiarów
    svgEl = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svgEl.classList.add('svg-overlay');
    svgEl.setAttribute('viewBox', `0 0 ${w} ${h}`);
    svgEl.setAttribute('preserveAspectRatio','xMidYMid meet');
    svgEl.style.pointerEvents = 'none';

    // tło do wyłapywania zdarzeń
    const bg = document.createElementNS(svgEl.namespaceURI,'rect');
    bg.setAttribute('x',0); bg.setAttribute('y',0); bg.setAttribute('width',w); bg.setAttribute('height',h);
    bg.setAttribute('fill','transparent'); bg.style.pointerEvents = 'all';
    bg.addEventListener('dblclick', ev => {
      ev.preventDefault();
      const p = toViewBoxPoint(svgEl, ev);
      addButton(p.x, p.y, w, h);
    });
    svgEl.appendChild(bg);

    // kliknięcie odznacza przycisk
    svgEl.addEventListener('click', ev => {
    const g = ev.target.closest && ev.target.closest('.svg-button-group');
    if (!g) clearSelection();
    });


    imageContainer.appendChild(imgEl);
    imageContainer.appendChild(svgEl);

    // również podwójne kliknięcie bezpośrednio na obraz
    imgEl.addEventListener('dblclick', ev => {
      const bbox = imgEl.getBoundingClientRect();
      const cx = ev.clientX - bbox.left, cy = ev.clientY - bbox.top;
      const vx = cx * (imgEl.naturalWidth / bbox.width);
      const vy = cy * (imgEl.naturalHeight / bbox.height);
      addButton(vx, vy, imgEl.naturalWidth, imgEl.naturalHeight);
    });
  };
}

/* konwersja event -> punkt viewBox */
function toViewBoxPoint(svg, ev) {
  const p = svg.createSVGPoint(); p.x = ev.clientX; p.y = ev.clientY;
  const inv = svg.getScreenCTM().inverse();
  const loc = p.matrixTransform(inv);
  return { x: loc.x, y: loc.y };
}

/* tworzenie przycisku (grupy) */
function addButton(cx, cy, imgW, imgH) {
  if (!svgEl) return;
  counter += 1;
  const name = `Bez_nazwy_${counter}`;
  const info = ''; // domyślnie puste dane
  const w = Math.max(30, imgW * 0.08);
  const h = Math.max(20, imgH * 0.06);

  const g = document.createElementNS(svgEl.namespaceURI,'g');
  g.classList.add('svg-button-group');
  g.setAttribute('data-name', name);
  g.setAttribute('data-info', info);
  g.setAttribute('transform', `translate(${cx - w/2}, ${cy - h/2})`);
  g.style.pointerEvents = 'all';

  const r = document.createElementNS(svgEl.namespaceURI,'rect');
  r.classList.add('svg-button-bg');
  r.setAttribute('x',0); r.setAttribute('y',0); r.setAttribute('width',w); r.setAttribute('height',h);
  r.setAttribute('rx', Math.min(12, h*0.4));
  r.setAttribute('fill','#ffd166'); r.setAttribute('stroke','#073642'); r.setAttribute('stroke-width', Math.max(1, w*0.01));

  const t = document.createElementNS(svgEl.namespaceURI,'text');
  t.classList.add('svg-button-text');
  t.setAttribute('x', w/2); t.setAttribute('y', h/2);
  t.setAttribute('dominant-baseline','middle'); t.setAttribute('text-anchor','middle');
  t.textContent = name;

  g.appendChild(r); g.appendChild(t);
  makeDraggable(g, svgEl, imgW, imgH, w, h); // prosty drag
  svgEl.appendChild(g);

  // zaznacz nowo dodany
  const obj = selectButton(g);
  updateSummary(); // automatyczne podsumowanie po dodaniu
  return obj;
}

/* zaznacz i zwróć obiekt {name, info} */
function selectButton(g) {
  if (selected && selected !== g) {
    // przywróć obrys poprzedniego
    const prevRect = selected.querySelector('rect');
    if (prevRect) prevRect.setAttribute('stroke','#073642');
  }
  selected = g;
  const name = g.getAttribute('data-name') || '';
  const info = g.getAttribute('data-info') || '';
  // wypełnij pola edycji
  selectedInfo.textContent = name || 'brak';
  nameInput.value = name;
  dataInput.value = info;
  // wyróżnij
  const rect = g.querySelector('rect'); if (rect) rect.setAttribute('stroke','#ff3366');
  return { name, info };
}

function clearSelection() {
  if (selected) {
    const r = selected.querySelector('rect'); if (r) r.setAttribute('stroke','#073642');
  }
  selected = null;
  selectedInfo.textContent = 'brak';
  nameInput.value = dataInput.value = '';
}

/* Zastosuj zmiany (name + info) do zaznaczonego przycisku */
applyBtn.addEventListener('click', () => {
  if (!selected) return alert('Brak wybranego przycisku.');
  const name = (nameInput.value || '').trim();
  const info = (dataInput.value || '').trim();
  selected.setAttribute('data-name', name);
  selected.setAttribute('data-info', info);
  const text = selected.querySelector('text'); if (text) text.textContent = name;
  selectedInfo.textContent = name || 'brak';
  updateSummary();
});

/* Usuń zaznaczony */
deleteBtn.addEventListener('click', () => {
  if (!selected) return alert('Brak wybranego przycisku do usunięcia.');
  selected.remove();
  selected = null;
  selectedInfo.textContent = 'brak';
  nameInput.value = dataInput.value = '';
  updateSummary();
});

/* Wyczyść wszystkie przyciski (poza tłem) */
clearBtn.addEventListener('click', () => {
  if (!svgEl) return;
  const groups = Array.from(svgEl.querySelectorAll('.svg-button-group'));
  groups.forEach(g => g.remove());
  selected = null;
  selectedInfo.textContent = 'brak';
  nameInput.value = dataInput.value = '';
  updateSummary();
});

/* prosty drag (przeniesienie grupy) */
function makeDraggable(group, svg, imgW, imgH, btnW, btnH) {
  let dragging = false;
  let moved = false;
  let start = null;

  group.addEventListener('mousedown', ev => {
    ev.preventDefault();
    dragging = true;
    moved = false;

    const p = toViewBoxPoint(svg, ev);
    const t = parseTranslate(group.getAttribute('transform'));
    start = { mx: p.x, my: p.y, gx: t.x, gy: t.y };

    // bring to top
    svg.appendChild(group);
  });

  window.addEventListener('mousemove', ev => {
    if (!dragging) return;
    const p = toViewBoxPoint(svg, ev);

    const dx = p.x - start.mx;
    const dy = p.y - start.my;

    // jeżeli ruszyłeś się więcej niż 3px → to już drag
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) moved = true;

    let nx = start.gx + dx, ny = start.gy + dy;
    nx = Math.max(0, Math.min(nx, imgW - btnW));
    ny = Math.max(0, Math.min(ny, imgH - btnH));

    group.setAttribute('transform', `translate(${nx}, ${ny})`);
  });

  window.addEventListener('mouseup', ev => {
    if (!dragging) return;
    dragging = false;

    // jeśli NIE było ruchu → traktuj jako CLICK
    if (!moved) {
      selectButton(group);
      updateSummary();
    } else {
      // był drag
      updateSummary();
    }
  });
}


/* parsowanie translate(x,y) */
function parseTranslate(t) {
  if (!t) return {x:0,y:0};
  const m = /translate\(\s*([-\d.]+)[ ,]+\s*([-\d.]+)\s*\)/.exec(t);
  return m ? { x: parseFloat(m[1]), y: parseFloat(m[2]) } : { x:0,y:0 };
}

/* Aktualizacja podsumowania i svgOutput */
function updateSummary() {
  if (!svgEl) { jsonOutput.value = ''; svgOutput.value = ''; return; }
  const names = Array.from(svgEl.querySelectorAll('.svg-button-group')).map(g => (g.getAttribute('data-name')||'').trim()).filter(Boolean);
  const uniq = Array.from(new Set(names));
  jsonOutput.value = JSON.stringify(uniq, null, 2);

  // serializuj warstwę przycisków (kopię)
  const clone = svgEl.cloneNode(true);
  // usuń tło rect (transparent) aby w eksportowanym svg były tylko przyciski, jeśli chcesz
  const bg = clone.querySelector('rect[fill="transparent"]'); if (bg) bg.remove();
  clone.removeAttribute('style');
  const text = new XMLSerializer().serializeToString(clone);
  svgOutput.value = text;
}

/* inicjalne czyszczenie pól */
updateSummary();
</script>

<script src="../copywright.js"></script>
</body>
</html>
